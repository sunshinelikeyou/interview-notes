import{_ as s,D as r,c as n,j as l,a as i,I as t,a4 as a,o}from"./chunks/framework.uym2WrGe.js";const q=JSON.parse('{"title":"CSS Part","description":"","frontmatter":{},"headers":[],"relativePath":"src/css.md","filePath":"src/css.md","lastUpdated":1724913643000}'),c={name:"src/css.md"},d=l("h1",{id:"css-part",tabindex:"-1"},[i("CSS Part "),l("a",{class:"header-anchor",href:"#css-part","aria-label":'Permalink to "CSS Part"'},"​")],-1),_={class:"table-of-contents"},u={href:"#什么是margin塌陷-margin合并-如何避免"},m={href:"#什么是bfc-如何触发"},p={href:"#css3有哪些新特性"},h={href:"#浏览器渲染网页的过程"},g={href:"#浏览器输入url发生了什么"},b={id:"什么是margin塌陷-margin合并-如何避免",tabindex:"-1"},f=l("a",{class:"header-anchor",href:"#什么是margin塌陷-margin合并-如何避免","aria-label":'Permalink to "什么是margin塌陷，margin合并，如何避免 <Badge type="tip" text="primary" />"'},"​",-1),x=a('<details class="details custom-block"><summary>回答 <a href="https://blog.csdn.net/Celester_best/article/details/127455732" target="_blank" rel="noreferrer">参考链接</a></summary><ul><li>margin塌陷（父子元素）：当一个元素有margin值，并且这个元素的父级元素没有边框、内边距和外边距时，那么这个元素的margin会设置到父级元素上。</li></ul><blockquote><p>现象：第一个蓝色盒子与顶部的距离应该只是example元素的padding值20px, 而实际上是20px+50px，因为蓝色盒子里面的白色盒子设置了margin-top: 50px; 塌陷到蓝色盒子上了。<br> 解决：给蓝色盒子设置一个边框或者内边距。或者触发<a href="#什么是bfc-如何触发">BFC</a></p></blockquote><div class="example"><div class="parent error"><div class="child"></div></div><div class="parent right"><div class="child"></div></div></div><ul><li>margin合并（兄弟元素）：当两个相邻元素的同一个方向都设置了margin值，那么这两个元素的margin会取最大的而不是累加。</li></ul><blockquote><p>现象：第二个蓝色盒子与顶部的距离应该是20px+50px，但实际上是50px，因为蓝色盒子设置的margin-top: 50px; 合并到第一个蓝色盒子上了。<br> 解决：触发蓝色盒子<a href="#什么是bfc-如何触发">BFC</a></p></blockquote></details>',1),y={id:"什么是bfc-如何触发",tabindex:"-1"},k=l("a",{class:"header-anchor",href:"#什么是bfc-如何触发","aria-label":'Permalink to "什么是BFC，如何触发 <Badge type="tip" text="primary" />"'},"​",-1),S=a('<details class="details custom-block"><summary>回答</summary><ul><li>概念：BFC（Block Formatting Context）块级格式化上下文，它规定了内部的块级元素如何布局，并且与这个块级元素外部毫不相干。</li><li>特性： <ol><li>内部的Box会在垂直方向上一个接一个的放置。</li><li>垂直方向上的距离由margin决定。</li><li>bfc的区域不会与float的元素区域重叠。</li><li>计算bfc的高度时，浮动元素也参与计算</li><li>bfc就是页面上的一个独立容器，容器里面的子元素不会影响外面元素。</li></ol></li><li>触发条件： <ol><li>浮动元素，float 除 none 以外的值</li><li>绝对定位元素，position 除 static 以外的值</li><li>display 为以下其中之一的值 inline-block，table-cell，table-caption、flex</li><li>overflow 除了 visible 以外的值（hidden，auto，scroll）</li><li>body 根元素</li></ol></li></ul></details>',1),C={id:"css3有哪些新特性",tabindex:"-1"},T=l("a",{class:"header-anchor",href:"#css3有哪些新特性","aria-label":'Permalink to "css3有哪些新特性 <Badge type="tip" text="primary" />"'},"​",-1),v=a('<details class="details custom-block"><summary>回答 <a href="https://blog.csdn.net/Feng_warm/article/details/140721144" target="_blank" rel="noreferrer">参考链接</a></summary><ol><li>新增选择器 <ul><li>属性选择器：允许根据元素的属性及属性值来选择元素，例如 [type=“text”]</li><li>伪类选择器：用于定义元素的特殊状态，如 :hover、:active、:visited等。</li><li>伪元素选择器：如::before，::after,::first-latter,::first-line等，允许在元素的内容前后插入新的内容或样式化元素的一部分。</li></ul></li><li>盒模型 <ul><li>css3引入了box-sizing属性，允许开发者在包括边框和内边距内的盒模型中更容易地工作，通过box-sizing：boder-box；。</li></ul></li><li>图片边框 <ul><li>boder-radius：允许创建圆角边框。</li><li>border-image：允许将图片用作边框。</li></ul></li><li>背景 <ul><li>多重背景：background-image属性现在可以包含多个URL，允许单个元素有多个背景图像。</li><li>background-size：允许你指定背景图像的大小。</li><li>background-origin和background-clip提供了更多的背景定位和裁剪选项。</li></ul></li><li>渐变 <ul><li>线性渐变和径向渐变允许创建平滑的颜色过渡效果，无需使用图像。</li></ul></li><li>文本效果 <ul><li>text-shadow：允许给文本添加阴影。</li><li>@font-face：允许使用网络上的字体文件，而不仅仅是用户计算机上已经安装的字体</li></ul></li><li>转换 <ul><li>允许元素进行旋转、缩放、倾斜或移动。。transition属性配合transform-origin属性可以实现这些效果。</li></ul></li><li>过渡 <ul><li>允许css属性值的变化在指定的持续时间内平滑过渡，增强了用户界面的交互性和视觉效果。</li></ul></li><li>动画 <ul><li>通过@keyframes规则，可以定义动画序列，然后使用animation属性将其应用到元素上。</li></ul></li><li>媒体查询 <ul><li>允许根据不同的媒体类型和条件应用不同的样式规则，是响应式网页设计的重要组成部分。</li></ul></li><li>多列布局 <ul><li>使用column-count，column-gap，column-rule等属性可以创建多列文本布局。</li></ul></li><li>弹性盒子 <ul><li>提供了一种更有效的方式布局、对齐和分配在容器中项目空间，即使他们的大小未知或是动态变化的。</li></ul></li><li>网格布局 <ul><li>一个二维布局系统，用于通过创建复杂的网格和对齐内容来布局网页。</li></ul></li></ol></details>',1),B={id:"浏览器渲染网页的过程",tabindex:"-1"},P=l("a",{class:"header-anchor",href:"#浏览器渲染网页的过程","aria-label":'Permalink to "浏览器渲染网页的过程 <Badge type="warning" text="middle" />"'},"​",-1),V=l("details",{class:"details custom-block"},[l("summary",null,"回答"),l("ol",null,[l("li",null,"解析HTML，构建DOM树。"),l("li",null,"解析CSS，构建CSSOM树。"),l("li",null,"将DOM树和CSSOM树合并成渲染树。"),l("li",null,"根据渲染树进行绘制。")])],-1),w={id:"浏览器输入url发生了什么",tabindex:"-1"},A=l("a",{class:"header-anchor",href:"#浏览器输入url发生了什么","aria-label":'Permalink to "浏览器输入URL发生了什么 <Badge type="warning" text="middle" />"'},"​",-1),N=l("details",{class:"details custom-block"},[l("summary",null,"回答"),l("ul",null,[l("li",null,"URL 解析"),l("li",null,"DNS 查询"),l("li",null,"TCP 连接"),l("li",null,"处理请求"),l("li",null,"接受响应"),l("li",null,"渲染页面")])],-1);function D(F,R,I,L,U,M){const e=r("Badge");return o(),n("div",null,[d,l("nav",_,[l("ul",null,[l("li",null,[l("a",u,[i("什么是margin塌陷，margin合并，如何避免 "),t(e,{type:"tip",text:"primary"})])]),l("li",null,[l("a",m,[i("什么是BFC，如何触发 "),t(e,{type:"tip",text:"primary"})])]),l("li",null,[l("a",p,[i("css3有哪些新特性 "),t(e,{type:"tip",text:"primary"})])]),l("li",null,[l("a",h,[i("浏览器渲染网页的过程 "),t(e,{type:"warning",text:"middle"})])]),l("li",null,[l("a",g,[i("浏览器输入URL发生了什么 "),t(e,{type:"warning",text:"middle"})])])])]),l("h2",b,[i("什么是margin塌陷，margin合并，如何避免 "),t(e,{type:"tip",text:"primary"}),i(),f]),x,l("h2",y,[i("什么是BFC，如何触发 "),t(e,{type:"tip",text:"primary"}),i(),k]),S,l("h2",C,[i("css3有哪些新特性 "),t(e,{type:"tip",text:"primary"}),i(),T]),v,l("h2",B,[i("浏览器渲染网页的过程 "),t(e,{type:"warning",text:"middle"}),i(),P]),V,l("h2",w,[i("浏览器输入URL发生了什么 "),t(e,{type:"warning",text:"middle"}),i(),A]),N])}const E=s(c,[["render",D]]);export{q as __pageData,E as default};
