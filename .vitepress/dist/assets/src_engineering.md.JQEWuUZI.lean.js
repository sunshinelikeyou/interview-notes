import{_ as s,D as n,c as r,j as e,a,I as i,a4 as l,o}from"./chunks/framework.uym2WrGe.js";const G=JSON.parse('{"title":"Engineering Part (前端工程化部分)","description":"","frontmatter":{},"headers":[],"relativePath":"src/engineering.md","filePath":"src/engineering.md","lastUpdated":1724921604000}'),d={name:"src/engineering.md"},p=e("h1",{id:"engineering-part-前端工程化部分",tabindex:"-1"},[a("Engineering Part (前端工程化部分) "),e("a",{class:"header-anchor",href:"#engineering-part-前端工程化部分","aria-label":'Permalink to "Engineering Part (前端工程化部分)"'},"​")],-1),c={id:"webpack-配置有哪些",tabindex:"-1"},h=e("a",{class:"header-anchor",href:"#webpack-配置有哪些","aria-label":'Permalink to "Webpack 配置有哪些？ <Badge type="tip" text="primary" />"'},"​",-1),k=l("",1),u={id:"loader-和-plugin-的区别",tabindex:"-1"},_=e("a",{class:"header-anchor",href:"#loader-和-plugin-的区别","aria-label":'Permalink to "loader 和 plugin 的区别？ <Badge type="tip" text="primary" />"'},"​",-1),m=l("",1),b={id:"什么是code-splitting",tabindex:"-1"},g=e("a",{class:"header-anchor",href:"#什么是code-splitting","aria-label":'Permalink to "什么是Code Splitting <Badge type="tip" text="primary" />"'},"​",-1),y=e("details",{class:"details custom-block"},[e("summary",null,"回答"),e("blockquote",null,[e("p",null,"概念：Code Splitting 代码分割，是一种优化技术，它允许将一个大的chunk拆分成多个小的chunk，从而实现按需加载，减少初始加载时间，并提高应用程序的性能 开启方式： 在webpack的配置文件中，配置optimization.splitChunksk")])],-1),S={id:"webpack的source-map-是什么-如何配置生成source-map",tabindex:"-1"},f=e("a",{class:"header-anchor",href:"#webpack的source-map-是什么-如何配置生成source-map","aria-label":'Permalink to "Webpack的Source Map 是什么？如何配置生成Source Map? <Badge type="tip" text="primary" />"'},"​",-1),x=e("details",{class:"details custom-block"},[e("summary",null,"回答"),e("blockquote",null,[e("p",null,"概念：Source Map 是源代码和构建后代码的映射关系。通常在开发阶段开启，用来调试代码，定位问题 配置方式： 在webpack的配置文件中，配置devtool:'source-map'")])],-1),E={id:"什么是-webpack-的热更新-hot-module-replacement-原理是什么",tabindex:"-1"},w=e("a",{class:"header-anchor",href:"#什么是-webpack-的热更新-hot-module-replacement-原理是什么","aria-label":'Permalink to "什么是 webpack 的热更新（Hot Module Replacement）？原理是什么？ <Badge type="warning" text="middle" />"'},"​",-1),C=e("details",{class:"details custom-block"},[e("summary",null,"回答"),e("blockquote",null,[e("p",null,"概念：Webpack 热更新（Hot Module Replacement）是指，在应用程序运行过程中，替换、添加或删除模块，而不需要重新加载页面。 原理：HRM的原理实际上是webpack-dev-server（WDS）和浏览器之间维护了一个websocket服务，当本地资源发生变化后，webpack会先将打包生成的新的模块代码放入内存中，然后WDS向浏览器推送更新，并附带上构建时的hash，让客户端和上一次的资源进行对比，如果不同就更新，如果相同就不做任何操作。")])],-1),T={id:"webpack-的构建流程",tabindex:"-1"},P=e("a",{class:"header-anchor",href:"#webpack-的构建流程","aria-label":'Permalink to "webpack 的构建流程 <Badge type="warning" text="middle" />"'},"​",-1),W=e("details",{class:"details custom-block"},[e("summary",null,"回答"),e("ol",null,[e("li",null,"初始化参数： 解析Webpack配置参数，合并Shell传入和webpack.config.js文件配置的参数，形成最终的配 置结果。"),e("li",null,"开始编译： 使用上一次得到的参数初始化compiler对象，注册所有配置的插件，插件监听Webpack构建生命周期的事件节点，做出相应的反应，执行对象的run方法开始执行编译。"),e("li",null,"确定入口： 从配置的entry入口，开始解析文件构建AST语法树，找出依赖，递归下去。"),e("li",null,"编译模块： 递归中根据文件类型和loader配置，调用所有配置的loader对文件进行转换，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。"),e("li",null,"完成模块编译： 完成模块编译。在经过第四步使用Loader翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系。"),e("li",null,"输出资源： 根据入口和模块之间的依赖关系，组装成一个个包含多个模块的Chunk，再把每个Chunk转换成单独的文件加入到输出列表，这步是可以修改输出内容的最后机会。"),e("li",null,"输出完成： 在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。")])],-1),v={id:"webpack的tree-shaking原理",tabindex:"-1"},B=e("a",{class:"header-anchor",href:"#webpack的tree-shaking原理","aria-label":'Permalink to "Webpack的Tree Shaking原理 <Badge type="warning" text="middle" />"'},"​",-1),F=l("",1),A={id:"如何减少打包后的代码体积",tabindex:"-1"},D=e("a",{class:"header-anchor",href:"#如何减少打包后的代码体积","aria-label":'Permalink to "如何减少打包后的代码体积？ <Badge type="warning" text="middle" />"'},"​",-1),V=e("details",{class:"details custom-block"},[e("summary",null,"回答"),e("ul",null,[e("li",null,"代码分割：将应用程序的代码划分为多个代码块，按需加载"),e("li",null,"Tree Shaking： 配置Webpack的Tree Shaking机制，去除未使用的代码"),e("li",null,"代码压缩： 使用工具如UglifyJS或Terser来压缩JavaScript代码"),e("li",null,"使用生产模式： 在Webpack中使用生产模式，通过设置mode: 'production'来启用优化"),e("li",null,"使用压缩工具： 使用现代的压缩工具，如Brotli和Gzip，来对静态资源进行压缩"),e("li",null,"使用CDN： 将项目中引用的静态资源路径修改为CDN上的路径，减少图片、字体等静态资源等打包")])],-1),N={id:"如何提高webpack的打包速度",tabindex:"-1"},I=e("a",{class:"header-anchor",href:"#如何提高webpack的打包速度","aria-label":'Permalink to "如何提高Webpack的打包速度？ <Badge type="warning" text="middle" />"'},"​",-1),M=l("",4);function R(j,z,H,q,J,$){const t=n("Badge");return o(),r("div",null,[p,e("h2",c,[a("Webpack 配置有哪些？ "),i(t,{type:"tip",text:"primary"}),a(),h]),k,e("h2",u,[a("loader 和 plugin 的区别？ "),i(t,{type:"tip",text:"primary"}),a(),_]),m,e("h2",b,[a("什么是Code Splitting "),i(t,{type:"tip",text:"primary"}),a(),g]),y,e("h2",S,[a("Webpack的Source Map 是什么？如何配置生成Source Map? "),i(t,{type:"tip",text:"primary"}),a(),f]),x,e("h2",E,[a("什么是 webpack 的热更新（Hot Module Replacement）？原理是什么？ "),i(t,{type:"warning",text:"middle"}),a(),w]),C,e("h2",T,[a("webpack 的构建流程 "),i(t,{type:"warning",text:"middle"}),a(),P]),W,e("h2",v,[a("Webpack的Tree Shaking原理 "),i(t,{type:"warning",text:"middle"}),a(),B]),F,e("h2",A,[a("如何减少打包后的代码体积？ "),i(t,{type:"warning",text:"middle"}),a(),D]),V,e("h2",N,[a("如何提高Webpack的打包速度？ "),i(t,{type:"warning",text:"middle"}),a(),I]),M])}const L=s(d,[["render",R]]);export{G as __pageData,L as default};
