import{_ as o,B as s,c as l,j as e,a as d,G as a,a2 as i,o as u}from"./chunks/framework.s54Xu68I.js";const C=JSON.parse('{"title":"Vue Part","description":"","frontmatter":{},"headers":[],"relativePath":"src/vue.md","filePath":"src/vue.md","lastUpdated":1725846101000}'),n={name:"src/vue.md"},m={class:"table-of-contents"},p={href:"#什么是mvvm模型-和mvc有什么区别"},v={href:"#vue的生命周期有哪些-各个生命周期的作用是什么"},y={href:"#vue中computed和watch的区别是什么"},f={href:"#vue的组件通信有哪些方式-都在什么场景下使用"},b={href:"#vue的双向数据绑定原理是什么-为什么vue3的性能更好-diff算法-ast-模板解析"},x={id:"什么是mvvm模型-和mvc有什么区别",tabindex:"-1"},h={id:"vue的生命周期有哪些-各个生命周期的作用是什么",tabindex:"-1"},M={id:"vue中computed和watch的区别是什么",tabindex:"-1"},V={id:"vue的组件通信有哪些方式-都在什么场景下使用",tabindex:"-1"},k={id:"vue的双向数据绑定原理是什么-为什么vue3的性能更好-diff算法-ast-模板解析",tabindex:"-1"};function P(w,t,B,g,O,D){const r=s("Badge");return u(),l("div",null,[t[21]||(t[21]=e("h1",{id:"vue-part",tabindex:"-1"},[d("Vue Part "),e("a",{class:"header-anchor",href:"#vue-part","aria-label":'Permalink to "Vue Part"'},"​")],-1)),e("nav",m,[e("ul",null,[e("li",null,[e("a",p,[t[0]||(t[0]=d("什么是MVVM模型？和MVC有什么区别？ ")),a(r,{type:"tip",text:"primary"})])]),e("li",null,[e("a",v,[t[1]||(t[1]=d("vue的生命周期有哪些？各个生命周期的作用是什么？ ")),a(r,{type:"tip",text:"primary"})])]),e("li",null,[e("a",y,[t[2]||(t[2]=d("vue中computed和watch的区别是什么？ ")),a(r,{type:"tip",text:"primary"})])]),e("li",null,[e("a",f,[t[3]||(t[3]=d("vue的组件通信有哪些方式？都在什么场景下使用？ ")),a(r,{type:"tip",text:"primary"})])]),t[5]||(t[5]=e("li",null,[e("a",{href:"#nexttick-的作用是什么-他的实现原理是什么"},"nextTick 的作用是什么？他的实现原理是什么？")],-1)),e("li",null,[e("a",b,[t[4]||(t[4]=d("vue的双向数据绑定原理是什么？为什么vue3的性能更好？diff算法，ast 模板解析 ")),a(r,{type:"warning",text:"middle"})])])])]),e("h2",x,[t[6]||(t[6]=d("什么是MVVM模型？和MVC有什么区别？ ")),a(r,{type:"tip",text:"primary"}),t[7]||(t[7]=d()),t[8]||(t[8]=e("a",{class:"header-anchor",href:"#什么是mvvm模型-和mvc有什么区别","aria-label":'Permalink to "什么是MVVM模型？和MVC有什么区别？ <Badge type="tip" text="primary" />"'},"​",-1))]),t[22]||(t[22]=e("details",{class:"details custom-block"},[e("summary",null,"展开查看"),e("blockquote",null,[e("p",null,"MVVM是Model-View-ViewModel的缩写。它是一种基于前端开发的架构模式，m表示模型（model），v表示视图（view），vm是视图模型（view-model）的缩写，用于连接视图和数据。和MVC架构不同的是，它采用双向绑定，数据的变化会自动更新到视图，视图的变化也会自动更新到数据。用户只需要关注数据的变化，而不需要手动操作DOM。降低耦合，有利于前后端分离开发。")])],-1)),e("h2",h,[t[9]||(t[9]=d("vue的生命周期有哪些？各个生命周期的作用是什么？ ")),a(r,{type:"tip",text:"primary"}),t[10]||(t[10]=d()),t[11]||(t[11]=e("a",{class:"header-anchor",href:"#vue的生命周期有哪些-各个生命周期的作用是什么","aria-label":'Permalink to "vue的生命周期有哪些？各个生命周期的作用是什么？ <Badge type="tip" text="primary" />"'},"​",-1))]),t[23]||(t[23]=i('<details class="details custom-block"><summary>展开查看</summary><table tabindex="0"><thead><tr><th>vue2生命周期</th><th>vue3生命周期</th><th>调用时机</th></tr></thead><tbody><tr><td>beforeCreate</td><td>setup</td><td>在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。</td></tr><tr><td>created</td><td>setup</td><td>实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。</td></tr><tr><td>beforeMount</td><td>onBeforeMount</td><td>在挂载开始之前被调用，相关的 render 函数首次被调用。此时模板编译完成，但是还未将模板渲染成dom</td></tr><tr><td>mounted</td><td>onMounted</td><td>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。</td></tr><tr><td>beforeUpdate</td><td>onBeforeUpdate</td><td>数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。</td></tr><tr><td>updated</td><td>onUpdated</td><td>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。</td></tr><tr><td>beforeDestroy</td><td>onBeforeUnmount</td><td>实例销毁之前调用。在这一步，实例仍然完全可用。</td></tr><tr><td>destroyed</td><td>onUnmounted</td><td>实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁</td></tr></tbody></table></details>',1)),e("h2",M,[t[12]||(t[12]=d("vue中computed和watch的区别是什么？ ")),a(r,{type:"tip",text:"primary"}),t[13]||(t[13]=d()),t[14]||(t[14]=e("a",{class:"header-anchor",href:"#vue中computed和watch的区别是什么","aria-label":'Permalink to "vue中computed和watch的区别是什么？ <Badge type="tip" text="primary" />"'},"​",-1))]),t[24]||(t[24]=i('<details class="details custom-block"><summary>展开查看</summary><table tabindex="0"><thead><tr><th>名称</th><th>作用</th><th>区别</th></tr></thead><tbody><tr><td>computed</td><td>计算属性</td><td>计算属性值会基于其响应式依赖被缓存,只有依赖值发生变化才会重新计算,Getter 不应有副作用,避免直接修改计算属性值</td></tr><tr><td>watch</td><td>监听属性</td><td>不缓存,监听属性值的变化,更改 DOM，动画效果，或是根据异步操作的结果去修改另一处的状态,监听多个数据源变化，更灵活</td></tr><tr><td>function</td><td>方法</td><td>不依赖收集，不缓存</td></tr></tbody></table></details>',1)),e("h2",V,[t[15]||(t[15]=d("vue的组件通信有哪些方式？都在什么场景下使用？ ")),a(r,{type:"tip",text:"primary"}),t[16]||(t[16]=d()),t[17]||(t[17]=e("a",{class:"header-anchor",href:"#vue的组件通信有哪些方式-都在什么场景下使用","aria-label":'Permalink to "vue的组件通信有哪些方式？都在什么场景下使用？ <Badge type="tip" text="primary" />"'},"​",-1))]),t[25]||(t[25]=i('<details class="details custom-block"><summary>展开查看</summary><table tabindex="0"><thead><tr><th>场景</th><th>通信方式</th></tr></thead><tbody><tr><td>父子组件</td><td>props、$emit、$parent、$children、ref、provide、inject</td></tr><tr><td>兄弟组件</td><td>eventBus、vuex、pinia、mitt</td></tr></tbody></table></details><h2 id="nexttick-的作用是什么-他的实现原理是什么" tabindex="-1">nextTick 的作用是什么？他的实现原理是什么？ <a class="header-anchor" href="#nexttick-的作用是什么-他的实现原理是什么" aria-label="Permalink to &quot;nextTick 的作用是什么？他的实现原理是什么？&quot;">​</a></h2><details class="details custom-block"><summary>展开查看</summary><blockquote><p>作用：在下一次 DOM 更新循环结束之后执行延迟回调。在 Vue 中，数据的变化会触发重新渲染 DOM，但实际上，Vue 的数据更新是异步的。也就是说，当我们修改了 Vue 实例的数据后，并不会立即进行 DOM 更新，而是在下一个事件循环中才会进行。Vue 会对进行多次数据变化进行合并，然后在下一个事件循环中进行一次性的 DOM 更新，从而减少不必要的 DOM 操作，提高性能 实现原理：nextTick的实现原理是使用了宏任务和微任务的异步队列。 Promise, MutationObserver, setImmediate(node环境下),setTimeout</p></blockquote></details>',3)),e("h2",k,[t[18]||(t[18]=d("vue的双向数据绑定原理是什么？为什么vue3的性能更好？diff算法，ast 模板解析 ")),a(r,{type:"warning",text:"middle"}),t[19]||(t[19]=d()),t[20]||(t[20]=e("a",{class:"header-anchor",href:"#vue的双向数据绑定原理是什么-为什么vue3的性能更好-diff算法-ast-模板解析","aria-label":'Permalink to "vue的双向数据绑定原理是什么？为什么vue3的性能更好？diff算法，ast 模板解析 <Badge type="warning" text="middle" />"'},"​",-1))]),t[26]||(t[26]=i('<details class="details custom-block"><summary>展开查看</summary><p>vue2双向数据绑定是通过Object.defineProperty()来实现的。vue2通过递归遍历所有属性，给每个属性添加getter和setter方法。通过getter和setter方法来监听数据变化，当数据发生变化时，触发对应属性的setter方法，从而改变对应的DOM。对于对象属性的新增和删除，vue2无法监听到变化。只能通过vue.set()方法来新增和删除属性。 数据劫持 =》 依赖收集 =》 视图更新<br> vue3通过proxy实现，proxy比defineProperty更优。Proxy可以直接监听数组和嵌套对象的变化，在初次渲染和更新时减少了需手动递归处理的性能开销。</p><ul><li>源码组织方式变化：使用 TS 重写</li><li>支持 Composition API：基于函数的API，更加灵活组织组件逻辑（vue2用的是options api）</li><li>响应式系统提升：Vue3中响应式数据原理改成proxy，可监听动态新增删除属性，以及数组变化</li><li>编译优化：vue2通过标记静态根节点优化diff，Vue3 标记和提升所有静态根节点，diff的时候只需要对比动态节点内容</li><li>打包体积优化：移除了一些不常用的api（inline-template、filter）</li><li>生命周期的变化：使用setup代替了之前的beforeCreate和created</li></ul></details>',1))])}const T=o(n,[["render",P]]);export{C as __pageData,T as default};
