import{_ as o,D as i,c as s,j as t,a as e,I as a,a4 as r,o as l}from"./chunks/framework.uym2WrGe.js";const j=JSON.parse('{"title":"Vue Part","description":"","frontmatter":{},"headers":[],"relativePath":"src/vue.md","filePath":"src/vue.md","lastUpdated":1724921604000}'),n={name:"src/vue.md"},_=t("h1",{id:"vue-part",tabindex:"-1"},[e("Vue Part "),t("a",{class:"header-anchor",href:"#vue-part","aria-label":'Permalink to "Vue Part"'},"​")],-1),u={class:"table-of-contents"},c={href:"#什么是mvvm模型-和mvc有什么区别"},h={href:"#vue的生命周期有哪些-各个生命周期的作用是什么"},p={href:"#vue中computed和watch的区别是什么"},m={href:"#vue的组件通信有哪些方式-都在什么场景下使用"},v={href:"#vue的双向数据绑定原理是什么-为什么vue3的性能更好-diff算法-ast-模板解析"},y={id:"什么是mvvm模型-和mvc有什么区别",tabindex:"-1"},f=t("a",{class:"header-anchor",href:"#什么是mvvm模型-和mvc有什么区别","aria-label":'Permalink to "什么是MVVM模型？和MVC有什么区别？ <Badge type="tip" text="primary" />"'},"​",-1),b=t("details",{class:"details custom-block"},[t("summary",null,"回答"),t("blockquote",null,[t("p",null,"MVVM是Model-View-ViewModel的缩写。它是一种基于前端开发的架构模式，m表示模型（model），v表示视图（view），vm是视图模型（view-model）的缩写，用于连接视图和数据。和MVC架构不同的是，它采用双向绑定，数据的变化会自动更新到视图，视图的变化也会自动更新到数据。用户只需要关注数据的变化，而不需要手动操作DOM。降低耦合，有利于前后端分离开发。")])],-1),x={id:"vue的生命周期有哪些-各个生命周期的作用是什么",tabindex:"-1"},V=t("a",{class:"header-anchor",href:"#vue的生命周期有哪些-各个生命周期的作用是什么","aria-label":'Permalink to "vue的生命周期有哪些？各个生命周期的作用是什么？ <Badge type="tip" text="primary" />"'},"​",-1),T=r('<details class="details custom-block"><summary>回答</summary><table tabindex="0"><thead><tr><th>vue2生命周期</th><th>vue3生命周期</th><th>调用时机</th></tr></thead><tbody><tr><td>beforeCreate</td><td>setup</td><td>在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。</td></tr><tr><td>created</td><td>setup</td><td>实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。</td></tr><tr><td>beforeMount</td><td>onBeforeMount</td><td>在挂载开始之前被调用，相关的 render 函数首次被调用。此时模板编译完成，但是还未将模板渲染成dom</td></tr><tr><td>mounted</td><td>onMounted</td><td>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。</td></tr><tr><td>beforeUpdate</td><td>onBeforeUpdate</td><td>数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。</td></tr><tr><td>updated</td><td>onUpdated</td><td>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。</td></tr><tr><td>beforeDestroy</td><td>onBeforeUnmount</td><td>实例销毁之前调用。在这一步，实例仍然完全可用。</td></tr><tr><td>destroyed</td><td>onUnmounted</td><td>实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁</td></tr></tbody></table></details>',1),P={id:"vue中computed和watch的区别是什么",tabindex:"-1"},M=t("a",{class:"header-anchor",href:"#vue中computed和watch的区别是什么","aria-label":'Permalink to "vue中computed和watch的区别是什么？ <Badge type="tip" text="primary" />"'},"​",-1),w=r('<details class="details custom-block"><summary>回答</summary><table tabindex="0"><thead><tr><th>名称</th><th>作用</th><th>区别</th></tr></thead><tbody><tr><td>computed</td><td>计算属性</td><td>计算属性值会基于其响应式依赖被缓存,只有依赖值发生变化才会重新计算,Getter 不应有副作用,避免直接修改计算属性值</td></tr><tr><td>watch</td><td>监听属性</td><td>不缓存,监听属性值的变化,更改 DOM，动画效果，或是根据异步操作的结果去修改另一处的状态,监听多个数据源变化，更灵活</td></tr><tr><td>function</td><td>方法</td><td>不依赖收集，不缓存</td></tr></tbody></table></details>',1),C={id:"vue的组件通信有哪些方式-都在什么场景下使用",tabindex:"-1"},S=t("a",{class:"header-anchor",href:"#vue的组件通信有哪些方式-都在什么场景下使用","aria-label":'Permalink to "vue的组件通信有哪些方式？都在什么场景下使用？ <Badge type="tip" text="primary" />"'},"​",-1),k=r('<details class="details custom-block"><summary>回答</summary><table tabindex="0"><thead><tr><th>场景</th><th>通信方式</th></tr></thead><tbody><tr><td>父子组件</td><td>props、$emit、$parent、$children、ref、provide、inject</td></tr><tr><td>兄弟组件</td><td>eventBus、vuex、pinia、mitt</td></tr></tbody></table></details>',1),A={id:"vue的双向数据绑定原理是什么-为什么vue3的性能更好-diff算法-ast-模板解析",tabindex:"-1"},B=t("a",{class:"header-anchor",href:"#vue的双向数据绑定原理是什么-为什么vue3的性能更好-diff算法-ast-模板解析","aria-label":'Permalink to "vue的双向数据绑定原理是什么？为什么vue3的性能更好？diff算法，ast 模板解析 <Badge type="warning" text="middle" />"'},"​",-1),g=r('<details class="details custom-block"><summary>回答</summary><p>vue2双向数据绑定是通过Object.defineProperty()来实现的。vue2通过递归遍历所有属性，给每个属性添加getter和setter方法。通过getter和setter方法来监听数据变化，当数据发生变化时，触发对应属性的setter方法，从而改变对应的DOM。对于对象属性的新增和删除，vue2无法监听到变化。只能通过vue.set()方法来新增和删除属性。 数据劫持 =》 依赖收集 =》 视图更新<br> vue3通过proxy实现，proxy比defineProperty更优。Proxy可以直接监听数组和嵌套对象的变化，在初次渲染和更新时减少了需手动递归处理的性能开销。</p><ul><li>源码组织方式变化：使用 TS 重写</li><li>支持 Composition API：基于函数的API，更加灵活组织组件逻辑（vue2用的是options api）</li><li>响应式系统提升：Vue3中响应式数据原理改成proxy，可监听动态新增删除属性，以及数组变化</li><li>编译优化：vue2通过标记静态根节点优化diff，Vue3 标记和提升所有静态根节点，diff的时候只需要对比动态节点内容</li><li>打包体积优化：移除了一些不常用的api（inline-template、filter）</li><li>生命周期的变化：使用setup代替了之前的beforeCreate和created</li></ul></details>',1);function D(I,N,$,O,U,E){const d=i("Badge");return l(),s("div",null,[_,t("nav",u,[t("ul",null,[t("li",null,[t("a",c,[e("什么是MVVM模型？和MVC有什么区别？ "),a(d,{type:"tip",text:"primary"})])]),t("li",null,[t("a",h,[e("vue的生命周期有哪些？各个生命周期的作用是什么？ "),a(d,{type:"tip",text:"primary"})])]),t("li",null,[t("a",p,[e("vue中computed和watch的区别是什么？ "),a(d,{type:"tip",text:"primary"})])]),t("li",null,[t("a",m,[e("vue的组件通信有哪些方式？都在什么场景下使用？ "),a(d,{type:"tip",text:"primary"})])]),t("li",null,[t("a",v,[e("vue的双向数据绑定原理是什么？为什么vue3的性能更好？diff算法，ast 模板解析 "),a(d,{type:"warning",text:"middle"})])])])]),t("h2",y,[e("什么是MVVM模型？和MVC有什么区别？ "),a(d,{type:"tip",text:"primary"}),e(),f]),b,t("h2",x,[e("vue的生命周期有哪些？各个生命周期的作用是什么？ "),a(d,{type:"tip",text:"primary"}),e(),V]),T,t("h2",P,[e("vue中computed和watch的区别是什么？ "),a(d,{type:"tip",text:"primary"}),e(),M]),w,t("h2",C,[e("vue的组件通信有哪些方式？都在什么场景下使用？ "),a(d,{type:"tip",text:"primary"}),e(),S]),k,t("h2",A,[e("vue的双向数据绑定原理是什么？为什么vue3的性能更好？diff算法，ast 模板解析 "),a(d,{type:"warning",text:"middle"}),e(),B]),g])}const q=o(n,[["render",D]]);export{j as __pageData,q as default};
